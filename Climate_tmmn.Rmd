---
title: "Climate data Gathering"
author: "Bryce DiNardo"
date: "2025-11-07"
output: html_document
---
This document demonstrates how to download daily minimum temperature data 
from gridMET for the year 2020, crop it to Oregon, and calculate the annual mean while keep data as a raster.

Install and load needed packages

```{r}
install.packages("amadeus")
install.packages("tigris")
install.packages("terra")
install.packages("sf")
library(terra)
library(tigris)
library(amadeus)
library(sf)
```

Set director for downloading Gridmat data as a .cd
```{r}
dir <- dir <- ("C:/Users/Bryce/Desktop") #I had trouble bring it right into my repo folder
```

Download the netCDF data file with download_data from gridmat using download_data
```{r}
#Variable == whatever variable you want to download
#Year = year of interest
download_data("gridmet",
              variable = "Minimum Near-Surface Air Temperature",
              year = 2020,
              directory_to_save = dir,
              acknowledgement = TRUE,
              download = TRUE,
              remove_command = TRUE,
              hash = TRUE)

```

Next need to get an Oregon shape file to crop our nation wide data to just our ROI using tigris
```{r}
states_2024 <- tigris::states(year = 2024)
oregon <- states_2024[states_2024$NAME == "Oregon", ]
#plot(oregon) #make sure we succeeded in getting Oregon boundary
```

Now process the .netfile to pull out out wanted data
```{r}
tmmn2020 <- process_covariates(
  covariate = "gridmet",
  variable  = "Minimum Near-Surface Air Temperature",
  date      = c("2020-01-01", "2020-12-31"), #this range gets use the whole year for the whole country
  path      = file.path(dir, "tmmn")
)

# Check structure and number of layers
str(tmmn2020)
nlyr(tmmn2020)  # should be 366 (leap year)
```
Check crs, and reproject tigris data to match climate data projection
Crop and mask our whole year whole country spat raster to just Orgeon
```{r}
# Check CRS of raster
crs(tmmn2020) #WGS84

# Reproject Oregon boundary to match raster CRS
oregon_proj <- terra::project(terra::vect(oregon), crs(tmmn2020))

# Now crop and mask safely
tmmn_or_crop <- terra::crop(tmmn2020, oregon_proj)
tmmn_or_mask <- terra::mask(tmmn_or_crop, oregon_proj)
```

Finally lets take all the rasters and calculate the mean minimum air tempature for the year 2020 taken from all the daily lows. 
```{r}
mean_tmmn_2020_OR <- terra::mean(tmmn_or_mask, na.rm = TRUE)

# Confirm single layer
nlyr(mean_tmmn_2020_OR)

# Plot annual mean raster
terra::plot(mean_tmmn_2020_OR)

```
Temperatures in Kelvin 
In short I 
- Downloaded and processed 366 daily rasters.
- Cropped/masked to Oregon.
- Computed a single annual mean raster.

Now lets see if I can write a function that can do this for any day of the year,
inputs year, directory, state autoset to year 
```{r}
#function works
# Function downloads gridMET data for a given climatic variable and year while placing the download into a directory
#should work with all variables from gridMET
gridMET_download <- function(year, var, dir) {
  
  # Download gridMET data for the year
  download_data("gridmet",
                variable = var,
                year = year,
                directory_to_save = dir,
                acknowledgement = TRUE,
                download = TRUE,
                remove_command = TRUE,
                hash = TRUE)
}
#test function
dir<-"C:/Users/Bryce/Desktop/tmmn"
gridMET_download(2018, "Maximum Near-Surface Air Temperature", dir)
#it worked!
#check down load
list.files(dir, recursive = TRUE, pattern = "tmmn")
```


New function that is separate from downloading the .nt file 
```{r}
#This function works 
#dont use for precp
#It take the year and directory of the net.cd file that you have saved and computes the mean of your temperature variable
annual_mean_tempMaxMin <- function(year, var, dir, state_name = "Oregon"){
  states_sf <- tigris::states(year = 2024)
  state_boundary <- states_sf[states_sf$NAME == state_name, ] #getting OR shp file
  
  # Process covariates for the full year and whatever variable you are using
  x <- process_covariates(
    covariate = "gridmet",
    variable  = var,
    date      = c(paste0(year, "-01-01"), paste0(year, "-12-31")),
    path      = file.path(dir)
  )
  
  # Reproject state boundary to match raster CRS
  state_proj <- terra::project(terra::vect(state_boundary), crs(x))
  
  # Crop and mask raster to state boundary
  crop <- terra::crop(x, state_proj)
  mask <- terra::mask(crop, state_proj)
  
  #  Calculate annual mean
  mean_x <- terra::mean(mask, na.rm = TRUE)
  
  return(mean_x)
}
OR_2018_2<-annual_mean_tempMaxMin(2018, "Minimum Near-Surface Air Temperature", dir ="C:/Users/Bryce/Desktop/tmmn/tmmn")
nlyr(OR_2019) #check to make sure the merging happened correctly 
terra::plot(OR_2019) #check that it plots 



```
```{r}
#holding on to this cause it's the skeloton
mean_tmmn_OR <- function(year, dir, state_name = "Oregon"){
  states_sf <- tigris::states(year = 2024)
  state_boundary <- states_sf[states_sf$NAME == state_name, ]
  
  # 3. Process covariates for the full year
  tmmn <- process_covariates(
    covariate = "gridmet",
    variable  = "Minimum Near-Surface Air Temperature",
    date      = c(paste0(year, "-01-01"), paste0(year, "-12-31")),
    path      = file.path(dir)
  )
  
  # 4. Reproject state boundary to match raster CRS
  state_proj <- terra::project(terra::vect(state_boundary), crs(tmmn))
  
  # 5. Crop and mask raster to state boundary
  tmmn_crop <- terra::crop(tmmn, state_proj)
  tmmn_mask <- terra::mask(tmmn_crop, state_proj)
  
  # 6. Calculate annual mean
  mean_tmmn <- terra::mean(tmmn_mask, na.rm = TRUE)
  
  return(mean_tmmn)
}

tmmn_2018<-mean_tmmn_OR(2018, "C:/Users/Bryce/Desktop/tmmn/tmmn")
nlyr(OR_2018)
terra::plot(OR_2018)
```

Testing with both new function with max 2018 data
```{r}
#Download 
gridMET_download(2018, "Maximum Near-Surface Air Temperature", dir)
#check
list.files("C:/Users/Bryce/Desktop/tmmn/")
#so a new folder has been names tmmx, will need to change dir for next function

#calc average tmmx
tmmx_2018<-annual_mean_tempMaxMin(2018,"Maximum Near-Surface Air Temperature", "C:/Users/Bryce/Desktop/tmmn/tmmx")
#check and graph
nlyr(tmmx_2018) #1
terra::plot(tmmx_2018) #very nice
```

Cool so now I have tmmx and tmmn for 2018. Lets try to calc the average
```{r}

# Calculate average annual temperature 
tmean_2018 <- (tmmn_2018 + tmmx_2018) / 2
nlyr(tmean_2018)
terra::plot(tmean_2018)
#Looks like it worked to me
```

Awesome lets make a quick function of it
```{r}
#this works too
tmean<-function(tmmn,tmmx){
  tmean<-(tmmn + tmmx) / 2
  return(tmean)
}
#Final test: good to go
tmean(tmmn_2018,tmmx_2018)
```
Great, so now I can download any varaible and calc tmmn, tmmx, and tmean. Lets do annual precp

```{r}
#Should be able to get the data no problem
gridMET_download(2018, "Precipitation", "C:/Users/Bryce/Desktop")
list.files("C:/Users/Bryce/Desktop/pr")
#data aquired
```
Now need to take our national pr data and turn it into oregon annual precp
```{r}

#Process covariate
pr_2018<-process_covariates(
   covariate = "gridmet",
    variable  = "Precipitation",
    date      = c("2018-01-01", "2018-12-31"),
    path      = file.path("C:/Users/Bryce/Desktop/pr")
  )
nlyr(pr_2018) #365 but whole country, mask to OR
#Aquire OR shp
OR_sf <- tigris::states(year = 2024)
  OR_boundary <- OR_sf[OR_sf$NAME == "Oregon", ] #getting OR shp file
#reproject
OR_proj <- terra::project(terra::vect(OR_boundary), crs(pr_2018))
#crop and mask
crop <- terra::crop(pr_2018, OR_proj)
  mask <- terra::mask(crop, OR_proj)
#Check work
terra::plot(mask)
nlyr(mask)

#Hard part
#calc precp
annual_precip_2018 <- sum(mask, na.rm = TRUE) #values are in mm 
nlyr(annual_precip_2018)
terra::plot(annual_precip_2018)

#Lets turn it into a function
annual_precp <- function(year, var, dir, state_name = "Oregon"){
  states_sf <- tigris::states(year = 2024)
  state_boundary <- states_sf[states_sf$NAME == state_name, ] #getting OR shp file
  
  # Process covariates for the full year and whatever variable you are using
  x <- process_covariates(
    covariate = "gridmet",
    variable  = var,
    date      = c(paste0(year, "-01-01"), paste0(year, "-12-31")),
    path      = file.path(dir)
  )
  
  # Reproject state boundary to match raster CRS
  state_proj <- terra::project(terra::vect(state_boundary), crs(x))
  
  # Crop and mask raster to state boundary
  crop <- terra::crop(x, state_proj)
  mask <- terra::mask(crop, state_proj)
  
  #  Calculate annual precp
  precp_x <- sum(mask, na.rm = TRUE)
  
  return(precp_x)
}
pr_2018<-annual_precp(2018,"Precipitation", "C:/Users/Bryce/Desktop/pr")
nlyr(pr_2018)
terra::plot(pr_2018)
#it works 
```

Let try to combine the two function with an if statment based on the var used, convert temperature into C but keep precp as mm

```{r}
process_annual_gridmet <- function(year, var, dir, state_name = "Oregon") {
  library(terra)
  library(tigris)

  # Load state boundary
  states_sf <- tigris::states(year = 2024)
  state_boundary <- states_sf[states_sf$NAME == state_name, ]

  # Process covariates
  x <- process_covariates(
    covariate = "gridmet",
    variable  = var,
    date      = c(paste0(year, "-01-01"), paste0(year, "-12-31")),
    path      = file.path(dir)
  )

  # Reproject, crop, and mask
  state_proj <- terra::project(terra::vect(state_boundary), crs(x))
  crop <- terra::crop(x, state_proj)
  mask <- terra::mask(crop, state_proj)

  # Determine operation based on variable
  if (var %in% c("tmmn", "tmmx", "Minimum Near-Surface Air Temperature", "Maximum Near-Surface Air Temperature")) {
    result <- mean(mask, na.rm = TRUE)
    result <- result - 273.15  # Convert from Kelvin to Celsius
  } else if (var %in% c("pr", "Precipitation")) {
    result <- sum(mask, na.rm = TRUE)  # Total annual precipitation in mm
  } else {
    stop("Unsupported variable. Please use 'tmmn', 'tmmx', or 'pr'.")
  }

  # Save raster
  out_name <- paste0(var, "_", year, ".tif")
  writeRaster(result, out_name, overwrite = TRUE)

  return(result)
}

```
Test

```{r}
getwd()
result<-process_annual_gridmet(2018, "Precipitation", "C:/Users/Bryce/Desktop/pr" )

#some checks
class(result) 
terra::plot(result)
summary(values(result))
plot(is.na(result), main = "NA Pixels in Annual Precipitation")


```

